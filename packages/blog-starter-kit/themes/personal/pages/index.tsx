import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { FeaturedArticle } from '../components/featured-article';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { NewsletterSection } from '../components/newsletter-section';
import { PersonalHeader } from '../components/personal-theme-header';
import { Hero } from '../components/hero';
import { AuthorSection } from '../components/author-section';
import { StartHereSection, StartHereSeries } from '../components/start-here-section';
import { TopicClusters, TopicCluster, TOPIC_CLUSTER_DEFS } from '../components/topic-clusters';
import { RecentArticles } from '../components/recent-articles';
import {
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PostFragment,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
	PublicationFragment,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

type Props = {
	publication: PublicationFragment;
	initialPosts: PostFragment[];
	topicClusters: TopicCluster[];
	startHereSeries: StartHereSeries | null;
};

export default function Index({ publication, initialPosts, topicClusters, startHereSeries }: Props) {
	const posts = initialPosts;
	const featuredPost = publication.pinnedPost ?? posts[0];

	return (
		<AppProvider publication={publication} posts={posts}>
			<Layout>
				<Head>
					<title>{publication.title}</title>
					<meta
						name="description"
						content={
							publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`
						}
					/>
					<meta property="twitter:card" content="summary_large_image"/>
					<meta property="twitter:title" content={publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'} />
					<meta property="twitter:description" content={publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`} />
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-5 flex flex-col gap-0 divide-y divide-neutral-200 dark:divide-neutral-800">
						<Hero />
					{startHereSeries && <StartHereSection series={startHereSeries} />}
					{featuredPost && (
						<>
							<FeaturedArticle post={featuredPost} />
							<TopicClusters clusters={topicClusters} />
							<RecentArticles posts={initialPosts} />
						</>
					)}
						
					<NewsletterSection />
					<AuthorSection />
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	// ── 1. Fetch first page ──────────────────────────────────────────────────
	const data = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
		GQL_ENDPOINT,
		PostsByPublicationDocument,
		{
			first: 20,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const publication = data.publication;
	if (!publication) {
		return { notFound: true };
	}

	const initialPosts = (publication.posts.edges ?? []).map((edge) => edge.node);

	// ── 2. Paginate to collect all posts for cluster + series computation ────
	const allPosts = [...initialPosts];
	let cursor = publication.posts.pageInfo.endCursor;
	let hasNextPage = !!publication.posts.pageInfo.hasNextPage;

	while (hasNextPage && cursor) {
		const next = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			MorePostsByPublicationDocument,
			{ first: 20, host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST, after: cursor },
		);
		if (!next.publication) break;
		allPosts.push(...next.publication.posts.edges.map((e) => e.node));
		cursor = next.publication.posts.pageInfo.endCursor;
		hasNextPage = !!next.publication.posts.pageInfo.hasNextPage;
	}

	// ── 3. Build topic clusters ───────────────────────────────────────────────
	// Posts are already newest-first from the API; take the 3 most recent per cluster.
	const topicClusters: TopicCluster[] = TOPIC_CLUSTER_DEFS.map((def) => ({
		...def,
		posts: allPosts
			.filter((p) => p.tags?.some((t) => t.slug === def.slug))
			.slice(0, 3),
	}));

	// ── 4. Derive "Start Here" series ─────────────────────────────────────────
	// Find the series that has the most posts; its oldest posts become the
	// curated reading list.
	const seriesCountMap = new Map<string, { name: string; slug: string; count: number }>();
	for (const post of allPosts) {
		if (!post.series) continue;
		const { id, name, slug } = post.series;
		const prev = seriesCountMap.get(id);
		seriesCountMap.set(id, { name, slug, count: (prev?.count ?? 0) + 1 });
	}

	const topSeries = [...seriesCountMap.values()].sort((a, b) => b.count - a.count)[0] ?? null;

	let startHereSeries: StartHereSeries | null = null;
	if (topSeries) {
		const seriesPosts = allPosts
			.filter((p) => p.series?.slug === topSeries.slug)
			.sort((a, b) => new Date(a.publishedAt).getTime() - new Date(b.publishedAt).getTime())
			.slice(0, 5);

		startHereSeries = {
			seriesName: topSeries.name,
			seriesSlug: topSeries.slug,
			posts: seriesPosts,
		};
	}

	return {
		props: {
			publication,
			initialPosts,
			initialPageInfo: publication.posts.pageInfo,
		topicClusters,
		startHereSeries,
		},
		revalidate: 1,
	};
};
