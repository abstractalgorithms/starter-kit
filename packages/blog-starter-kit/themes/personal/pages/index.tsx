import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import { useState } from 'react';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { CategoriesSection } from '../components/categories-section';
import { FeaturedArticle } from '../components/featured-article';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { MinimalPosts } from '../components/minimal-posts';
import { NewsletterSection } from '../components/newsletter-section';
import { PersonalHeader } from '../components/personal-theme-header';
import { Hero } from '../components/hero';
import {
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PageInfoFragment,
	PostFragment,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
	PublicationFragment,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

type Props = {
	publication: PublicationFragment;
	initialPosts: PostFragment[];
	initialPageInfo: PageInfoFragment;
	heroStats: {
		articlesCount: number;
		categoriesCount: number;
		seriesCount: number;
	};
};

export default function Index({ publication, initialPosts, initialPageInfo, heroStats }: Props) {
	const [posts, setPosts] = useState<PostFragment[]>(initialPosts);
	const [pageInfo, setPageInfo] = useState<Props['initialPageInfo']>(initialPageInfo);
	const [visibleLatestCount, setVisibleLatestCount] = useState(3);
	const [isLoadingMore, setIsLoadingMore] = useState(false);
	const featuredPost = publication.pinnedPost ?? posts[0];
	const latestPostsAll = featuredPost
		? posts.filter((post) => post.id !== featuredPost.id)
		: posts;
	const latestPosts = latestPostsAll.slice(0, visibleLatestCount);
	const canLoadMoreLatest =
		visibleLatestCount < latestPostsAll.length || !!pageInfo.hasNextPage;

	const loadMore = async () => {
		if (isLoadingMore) {
			return;
		}

		const nextVisibleCount = visibleLatestCount + 3;
		setVisibleLatestCount(nextVisibleCount);

		if (nextVisibleCount <= latestPostsAll.length || !pageInfo.hasNextPage || !pageInfo.endCursor) {
			return;
		}

		setIsLoadingMore(true);
		const data = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			MorePostsByPublicationDocument,
			{
				first: 20,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
				after: pageInfo.endCursor,
			},
		);
		if (!data.publication) {
			setIsLoadingMore(false);
			return;
		}
		const newPosts = data.publication.posts.edges.map((edge) => edge.node);
		setPosts((prevPosts) => [...prevPosts, ...newPosts]);
		setPageInfo(data.publication.posts.pageInfo);
		setIsLoadingMore(false);
	};
	return (
		<AppProvider publication={publication} posts={posts}>
			<Layout>
				<Head>
					<title>{publication.title}</title>
					<meta
						name="description"
						content={
							publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`
						}
					/>
					<meta property="twitter:card" content="summary_large_image"/>
					<meta property="twitter:title" content={publication.displayTitle || publication.title || 'Hashnode Blog Starter Kit'} />
					<meta property="twitter:description" content={publication.descriptionSEO || publication.title || `${publication.author.name}'s Blog`} />
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-5 flex flex-col gap-0 divide-y divide-neutral-200 dark:divide-neutral-800">
						<Hero stats={heroStats} />
						{featuredPost && (
							<>
								<FeaturedArticle post={featuredPost} />
								
								<section className="w-full py-12">
									<h2 className="text-2xl md:text-3xl font-bold mb-8 text-neutral-900 dark:text-neutral-50">
										Latest Articles
									</h2>
									<div className="w-full">
										<MinimalPosts context="home" posts={latestPosts} />
									</div>
									{canLoadMoreLatest && (
										<div className="flex justify-center mt-10">
											<button 
												onClick={loadMore}
												disabled={isLoadingMore}
												className="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-colors"
											>
												{isLoadingMore ? 'Loading...' : 'Load more articles'}
											</button>
										</div>
									)}
								</section>
							</>
						)}
						
						<CategoriesSection posts={posts} />
						<NewsletterSection />
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	const data = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
		GQL_ENDPOINT,
		PostsByPublicationDocument,
		{
			first: 20,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const publication = data.publication;
	if (!publication) {
		return {
			notFound: true,
		};
	}
	const initialPosts = (publication.posts.edges ?? []).map((edge) => edge.node);

	const allPosts = [...initialPosts];
	let cursor = publication.posts.pageInfo.endCursor;
	let hasNextPage = !!publication.posts.pageInfo.hasNextPage;

	while (hasNextPage && cursor) {
		const nextPage = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			MorePostsByPublicationDocument,
			{
				first: 20,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
				after: cursor,
			},
		);

		if (!nextPage.publication) {
			break;
		}

		const nextPosts = nextPage.publication.posts.edges.map((edge) => edge.node);
		allPosts.push(...nextPosts);
		cursor = nextPage.publication.posts.pageInfo.endCursor;
		hasNextPage = !!nextPage.publication.posts.pageInfo.hasNextPage;
	}

	const categorySlugs = new Set<string>();
	const seriesIds = new Set<string>();

	for (const post of allPosts) {
		for (const tag of post.tags ?? []) {
			categorySlugs.add(tag.slug);
		}
		if (post.series?.id) {
			seriesIds.add(post.series.id);
		}
	}

	const heroStats = {
		articlesCount: allPosts.length,
		categoriesCount: categorySlugs.size,
		seriesCount: seriesIds.size,
	};

	return {
		props: {
			publication,
			initialPosts,
			initialPageInfo: publication.posts.pageInfo,
			heroStats,
		},
		revalidate: 1,
	};
};
