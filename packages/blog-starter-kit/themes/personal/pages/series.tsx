import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { PersonalHeader } from '../components/personal-theme-header';
import {
	PublicationFragment,
	PostFragment,
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

type Series = {
	id: string;
	name: string;
	slug: string;
	coverImage?: string;
	postCount: number;
};

type Props = {
	publication: PublicationFragment;
	series: Series[];
	footerPosts: PostFragment[];
};

export default function SeriesPage({ publication, series, footerPosts }: Props) {
	return (
		<AppProvider publication={publication} footerPosts={footerPosts}>
			<Layout>
				<Head>
					<title>All Series - {publication.title}</title>
					<meta
						name="description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta property="og:title" content={`All Series - ${publication.title}`} />
					<meta
						property="og:description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<meta property="twitter:card" content="summary_large_image" />
					<meta property="twitter:title" content={`All Series - ${publication.title}`} />
					<meta
						property="twitter:description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-5 flex flex-col gap-0">
						<section className="w-full py-12">
							<div className="mb-12">
								<h1 className="text-4xl md:text-5xl font-bold text-neutral-900 dark:text-neutral-50 mb-4">
									All Series
								</h1>
								<p className="text-lg text-neutral-600 dark:text-neutral-300">
									Comprehensive guides and tutorial series covering various topics.
								</p>
							</div>

							{series.length > 0 ? (
								<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
									{series.map((s) => (
										<Link key={s.id} href={`/series/${s.slug}`}>
											<div className="group h-full">
												<div className="flex flex-col h-full p-6 rounded-lg border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 hover:border-blue-500 dark:hover:border-blue-500 hover:shadow-lg transition-all duration-300">
													{s.coverImage && (
														<div className="relative w-full h-48 overflow-hidden rounded-md mb-4 -m-6 mb-4">
															<img
																src={s.coverImage}
																alt={s.name}
																className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
															/>
														</div>
													)}
													<div className="flex flex-col flex-grow">
														<h3 className="text-lg font-bold text-neutral-900 dark:text-neutral-50 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors line-clamp-2 mb-3 capitalize">
															{s.name}
														</h3>
														<div className="text-sm text-neutral-500 dark:text-neutral-400 pt-3 border-t border-neutral-200 dark:border-neutral-800">
															{s.postCount} article{s.postCount !== 1 ? 's' : ''}
														</div>
													</div>
												</div>
											</div>
										</Link>
									))}
								</div>
							) : (
								<div className="text-center py-12">
									<p className="text-lg text-neutral-600 dark:text-neutral-400">
										No series available yet.
									</p>
								</div>
							)}
						</section>
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	try {
		const data = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			PostsByPublicationDocument,
			{
				first: 50,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
			},
		);

		const publication = data.publication;
		if (!publication) {
			return {
				notFound: true,
			};
		}

		// Extract unique series from posts
		const seriesMap = new Map<string, Series>();
		
		const allPosts = [...(publication.posts.edges ?? []).map((e) => e.node)];
		let cursor = publication.posts.pageInfo?.endCursor;
		let hasNextPage = !!publication.posts.pageInfo?.hasNextPage;

		while (hasNextPage && cursor) {
			const nextPage = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
				GQL_ENDPOINT,
				MorePostsByPublicationDocument,
				{ first: 20, host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST, after: cursor },
			);
			if (!nextPage.publication) break;
			allPosts.push(...nextPage.publication.posts.edges.map((e) => e.node));
			cursor = nextPage.publication.posts.pageInfo.endCursor;
			hasNextPage = !!nextPage.publication.posts.pageInfo.hasNextPage;
		}

		allPosts.forEach((post) => {
			const s = post.series;
			if (s && s.id && !seriesMap.has(s.id)) {
				seriesMap.set(s.id, {
					id: s.id,
					name: s.name,
					slug: s.slug,
					postCount: allPosts.filter((p) => p.series?.id === s.id).length,
				});
			}
		});

		const series = Array.from(seriesMap.values()).sort((a, b) => b.postCount - a.postCount);

		return {
			props: {
				publication,
				series,
				footerPosts: allPosts,
			},
			revalidate: 1,
		};
	} catch (error) {
		console.error('Error fetching series:', error);
		return {
			notFound: true,
		};
	}
};
