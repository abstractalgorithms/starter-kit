import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { PersonalHeader } from '../components/personal-theme-header';
import {
	PublicationFragment,
	PostFragment,
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

type Series = {
	id: string;
	name: string;
	slug: string;
	coverImage?: string;
	postCount: number;
};

type Props = {
	publication: PublicationFragment;
	series: Series[];
	footerPosts: PostFragment[];
};

const ACCENT_COLORS = [
	'border-l-blue-500',
	'border-l-emerald-500',
	'border-l-purple-500',
	'border-l-orange-500',
	'border-l-teal-500',
	'border-l-rose-500',
] as const;

export default function SeriesPage({ publication, series, footerPosts }: Props) {
	return (
		<AppProvider publication={publication} footerPosts={footerPosts}>
			<Layout>
				<Head>
					<title>All Series - {publication.title}</title>
					<meta
						name="description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta property="og:title" content={`All Series - ${publication.title}`} />
					<meta
						property="og:description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta
						property="og:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<meta property="twitter:card" content="summary_large_image" />
					<meta property="twitter:title" content={`All Series - ${publication.title}`} />
					<meta
						property="twitter:description"
						content={`Explore all series on ${publication.title}. Comprehensive guides and tutorials.`}
					/>
					<meta
						property="twitter:image"
						content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{
							__html: JSON.stringify(addPublicationJsonLd(publication)),
						}}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-5 pt-10 pb-20">
						{/* Back nav */}
						<Link
							href="/"
							className="inline-flex items-center gap-1.5 text-sm text-neutral-400 dark:text-neutral-500 hover:text-blue-600 dark:hover:text-blue-400 transition-colors mb-10 group"
						>
							<svg
								xmlns="http://www.w3.org/2000/svg"
								viewBox="0 0 20 20"
								fill="currentColor"
								className="w-4 h-4 group-hover:-translate-x-0.5 transition-transform"
							>
								<path
									fillRule="evenodd"
									d="M17 10a.75.75 0 01-.75.75H5.612l4.158 3.96a.75.75 0 11-1.04 1.08l-5.5-5.25a.75.75 0 010-1.08l5.5-5.25a.75.75 0 111.04 1.08L5.612 9.25H16.25A.75.75 0 0117 10z"
									clipRule="evenodd"
								/>
							</svg>
							Home
						</Link>

						{/* Page header */}
						<div className="mb-10">
							<p className="text-[10px] font-mono uppercase tracking-widest text-neutral-400 dark:text-neutral-500 mb-2">
								Learning Paths
							</p>
							<h1 className="text-4xl md:text-5xl font-extrabold tracking-tight text-neutral-900 dark:text-neutral-50 mb-3">
								All Series
							</h1>
							<p className="text-lg text-neutral-500 dark:text-neutral-400 max-w-xl">
								Structured, end-to-end guides â€” read them in order for the full picture.
							</p>
						</div>

						{series.length > 0 ? (
							<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
								{series.map((s, i) => (
									<Link
										key={s.id}
										href={`/series/${s.slug}`}
										className={`group flex flex-col h-full rounded-xl border border-l-4 ${ACCENT_COLORS[i % ACCENT_COLORS.length]} border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-950 hover:shadow-md hover:-translate-y-0.5 transition-all duration-200 overflow-hidden`}
									>
										{s.coverImage && (
											<div className="w-full h-36 overflow-hidden">
												<img
													src={s.coverImage}
													alt={s.name}
													className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
												/>
											</div>
										)}
										<div className="flex flex-col flex-grow p-5">
											<h3 className="text-base font-bold text-neutral-900 dark:text-neutral-50 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors line-clamp-2 mb-auto capitalize">
												{s.name}
											</h3>
											<div className="flex items-center justify-between mt-4 pt-3 border-t border-neutral-100 dark:border-neutral-800">
												<span className="text-xs font-mono text-neutral-400 dark:text-neutral-500">
													{s.postCount} article{s.postCount !== 1 ? 's' : ''}
												</span>
												<svg
													xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 20 20"
													fill="currentColor"
													className="w-4 h-4 text-neutral-300 dark:text-neutral-600 group-hover:text-blue-500 group-hover:translate-x-0.5 transition-all"
												>
													<path
														fillRule="evenodd"
														d="M3 10a.75.75 0 01.75-.75h10.638L10.23 5.29a.75.75 0 111.04-1.08l5.5 5.25a.75.75 0 010 1.08l-5.5 5.25a.75.75 0 11-1.04-1.08l4.158-3.96H3.75A.75.75 0 013 10z"
														clipRule="evenodd"
													/>
												</svg>
											</div>
										</div>
									</Link>
								))}
							</div>
						) : (
							<div className="flex flex-col items-center justify-center py-20 border border-dashed border-neutral-200 dark:border-neutral-800 rounded-xl">
								<p className="text-[10px] font-mono uppercase tracking-widest text-neutral-400 dark:text-neutral-500 mb-2">
									Coming soon
								</p>
								<p className="text-base text-neutral-500 dark:text-neutral-400">
									No series available yet.
								</p>
							</div>
						)}
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	try {
		const data = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			PostsByPublicationDocument,
			{
				first: 50,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
			},
		);

		const publication = data.publication;
		if (!publication) {
			return {
				notFound: true,
			};
		}

		// Extract unique series from posts
		const seriesMap = new Map<string, Series>();
		
		const allPosts = [...(publication.posts.edges ?? []).map((e) => e.node)];
		let cursor = publication.posts.pageInfo?.endCursor;
		let hasNextPage = !!publication.posts.pageInfo?.hasNextPage;

		while (hasNextPage && cursor) {
			const nextPage = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
				GQL_ENDPOINT,
				MorePostsByPublicationDocument,
				{ first: 20, host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST, after: cursor },
			);
			if (!nextPage.publication) break;
			allPosts.push(...nextPage.publication.posts.edges.map((e) => e.node));
			cursor = nextPage.publication.posts.pageInfo.endCursor;
			hasNextPage = !!nextPage.publication.posts.pageInfo.hasNextPage;
		}

		allPosts.forEach((post) => {
			const s = post.series;
			if (s && s.id && !seriesMap.has(s.id)) {
				seriesMap.set(s.id, {
					id: s.id,
					name: s.name,
					slug: s.slug,
					postCount: allPosts.filter((p) => p.series?.id === s.id).length,
				});
			}
		});

		const series = Array.from(seriesMap.values()).sort((a, b) => b.postCount - a.postCount);

		return {
			props: {
				publication,
				series,
				footerPosts: allPosts,
			},
			revalidate: 1,
		};
	} catch (error) {
		console.error('Error fetching series:', error);
		return {
			notFound: true,
		};
	}
};
