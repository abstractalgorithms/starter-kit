import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { Container } from '../../components/container';
import { AppProvider } from '../../components/contexts/appContext';
import { DateFormatter } from '../../components/date-formatter';
import { Footer } from '../../components/footer';
import { Layout } from '../../components/layout';
import { MinimalPosts } from '../../components/minimal-posts';
import { PersonalHeader } from '../../components/personal-theme-header';
import { getFooterPosts } from '../../lib/api/footerData';
import {
	PostFragment,
	PublicationFragment,
	SeriesPostsByPublicationDocument,
	SeriesPostsByPublicationQuery,
	SeriesPostsByPublicationQueryVariables,
} from '../../generated/graphql';

type SeriesInfo = {
	id: string;
	name: string;
	slug: string;
	coverImage?: string | null;
	description?: string | null;
};

type Props = {
	publication: PublicationFragment;
	posts: PostFragment[];
	series: SeriesInfo;
	footerPosts: PostFragment[];
};

export default function SeriesDetailPage({ publication, posts, series, footerPosts }: Props) {
	const title = `${series.name} - ${publication.title}`;

	return (
		<AppProvider publication={publication} footerPosts={footerPosts}>
			<Layout>
				<Head>
					<title>{title}</title>
					<meta name="description" content={series.description ?? `Posts in the ${series.name} series`} />
					<meta property="og:title" content={title} />
					<meta property="og:description" content={series.description ?? `Posts in the ${series.name} series`} />
					<meta
						property="og:image"
						content={series.coverImage ?? publication.ogMetaData.image ?? getAutogeneratedPublicationOG(publication)}
					/>
					<meta property="twitter:card" content="summary_large_image" />
					<meta property="twitter:title" content={title} />
					<meta
						property="twitter:image"
						content={series.coverImage ?? publication.ogMetaData.image ?? getAutogeneratedPublicationOG(publication)}
					/>
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{ __html: JSON.stringify(addPublicationJsonLd(publication)) }}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-5 flex flex-col gap-0">
						<section className="w-full py-12">
							{/* ── Series Hero: header + cover image side-by-side ── */}
							<div className={`flex flex-col ${series.coverImage ? 'md:flex-row md:items-center md:gap-10' : ''} mb-12`}>
								{/* Left: breadcrumb, label, title, description, count */}
								<div className={series.coverImage ? 'flex-1 min-w-0' : 'w-full'}>
									<Link
										href="/series"
										className="inline-flex items-center gap-1 text-sm font-medium text-neutral-500 dark:text-neutral-400 hover:text-neutral-900 dark:hover:text-neutral-50 transition-colors mb-4"
									>
										← All Series
									</Link>
									<p className="font-semibold uppercase text-sm text-neutral-600 dark:text-neutral-400 mb-3">
										Series
									</p>
									<h1 className="text-4xl md:text-5xl font-bold text-neutral-900 dark:text-neutral-50 mb-4">
										{series.name}
									</h1>
									{series.description && (
										<div
											className="text-lg text-neutral-600 dark:text-neutral-300 mb-4"
											dangerouslySetInnerHTML={{ __html: series.description }}
										/>
									)}
									<p className="text-base text-neutral-500 dark:text-neutral-400">
										{posts.length} article{posts.length !== 1 ? 's' : ''} in this series
									</p>								{posts.length > 0 && (() => {
									const latestDate = posts.reduce((latest, p) =>
										p.publishedAt > latest ? p.publishedAt : latest, posts[0].publishedAt);
									const totalRead = posts.reduce((sum, p) => sum + (p.readTimeInMinutes ?? 0), 0);
									return (
										<div className="flex flex-wrap items-center gap-x-3 gap-y-1 mt-4 pt-4 border-t border-neutral-100 dark:border-neutral-800">
											<span className="text-sm font-semibold text-neutral-700 dark:text-neutral-300">{publication.title}</span>
											<span className="text-neutral-200 dark:text-neutral-700">·</span>
											<time className="text-sm text-neutral-400 dark:text-neutral-500">
												<DateFormatter dateString={latestDate} />
											</time>
											<span className="text-neutral-200 dark:text-neutral-700">·</span>
											<span className="text-sm text-neutral-400 dark:text-neutral-500">{totalRead} min read</span>
										</div>
									);
								})()}								</div>

								{/* Right: cover image */}
								{series.coverImage && (
									<div className="w-full md:w-2/5 shrink-0 mt-8 md:mt-0 h-52 md:h-64 rounded-xl overflow-hidden ring-1 ring-neutral-200 dark:ring-neutral-800 shadow-sm">
										<img
											src={series.coverImage}
											alt={series.name}
											className="w-full h-full object-cover"
										/>
									</div>
								)}
							</div>
							<hr className="border-neutral-200 dark:border-neutral-800 mb-10" />
							{posts.length > 0 ? (
								<MinimalPosts context="series" posts={posts} />
							) : (
								<p className="text-neutral-600 dark:text-neutral-400 py-8 text-center">
									No posts in this series yet.
								</p>
							)}
						</section>
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

type Params = {
	slug: string;
};

export const getStaticProps: GetStaticProps<Props, Params> = async ({ params }) => {
	if (!params) throw new Error('No params');

	const data = await request<SeriesPostsByPublicationQuery, SeriesPostsByPublicationQueryVariables>(
		process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT,
		SeriesPostsByPublicationDocument,
		{
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
			seriesSlug: params.slug,
			first: 20,
		},
	);

	const publication = data.publication;
	if (!publication || !publication.series) {
		return { notFound: true };
	}

	const { series } = publication;
	const posts = series.posts.edges.map((edge) => edge.node);
	const footerPosts = await getFooterPosts();

	return {
		props: {
			publication,
			posts,
			series: {
				id: series.id,
				name: series.name,
				slug: series.slug,
				coverImage: series.coverImage ?? null,
				description: series.description?.html ?? null,
			},
			footerPosts,
		},
		revalidate: 1,
	};
};

export async function getStaticPaths() {
	return {
		paths: [],
		fallback: 'blocking',
	};
}
