import { addPublicationJsonLd } from '@starter-kit/utils/seo/addPublicationJsonLd';
import { getAutogeneratedPublicationOG } from '@starter-kit/utils/social/og';
import request from 'graphql-request';
import { GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { useState, useMemo } from 'react';
import { Waypoint } from 'react-waypoint';
import { Container } from '../components/container';
import { AppProvider } from '../components/contexts/appContext';
import { Footer } from '../components/footer';
import { Layout } from '../components/layout';
import { MinimalPosts } from '../components/minimal-posts';
import { PersonalHeader } from '../components/personal-theme-header';
import {
	MorePostsByPublicationDocument,
	MorePostsByPublicationQuery,
	MorePostsByPublicationQueryVariables,
	PageInfoFragment,
	PostFragment,
	PostsByPublicationDocument,
	PostsByPublicationQuery,
	PostsByPublicationQueryVariables,
	PublicationFragment,
} from '../generated/graphql';

const GQL_ENDPOINT = process.env.NEXT_PUBLIC_HASHNODE_GQL_ENDPOINT;

const toTitleCase = (str: string) =>
	str.replace(/\w\S*/g, (w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase());

type Props = {
	publication: PublicationFragment;
	initialPosts: PostFragment[];
	initialPageInfo: PageInfoFragment;
};

const UNCATEGORIZED = '__uncategorized__';

export default function AllPostsPage({ publication, initialPosts, initialPageInfo }: Props) {
	const [posts, setPosts] = useState<PostFragment[]>(
		[...initialPosts].sort((a, b) =>
			new Date(b.publishedAt || 0).getTime() - new Date(a.publishedAt || 0).getTime()
		)
	);
	const [pageInfo, setPageInfo] = useState<Props['initialPageInfo']>(initialPageInfo);
	const [loadedMore, setLoadedMore] = useState(false);
	const [activeCategory, setActiveCategory] = useState<string | null>(null);

	/** Build ordered list of categories and a map from category slug → posts */
	const { categories, grouped } = useMemo(() => {
		const order: { slug: string; name: string }[] = [];
		const seen = new Set<string>();
		const map = new Map<string, PostFragment[]>();

		for (const post of posts) {
			const tags = (post.tags ?? []).filter((t): t is NonNullable<typeof t> => !!t?.slug);
			if (tags.length === 0) {
				if (!seen.has(UNCATEGORIZED)) {
					seen.add(UNCATEGORIZED);
					order.push({ slug: UNCATEGORIZED, name: 'Uncategorized' });
				}
				map.set(UNCATEGORIZED, [...(map.get(UNCATEGORIZED) ?? []), post]);
			} else {
				// Assign to the primary (first) tag only so each post appears exactly once
				const primaryTag = tags[0];
				if (!primaryTag?.slug) continue;
				if (!seen.has(primaryTag.slug)) {
					seen.add(primaryTag.slug);
					order.push({ slug: primaryTag.slug, name: toTitleCase(primaryTag.name ?? primaryTag.slug) });
				}
				map.set(primaryTag.slug, [...(map.get(primaryTag.slug) ?? []), post]);
			}
		}

		// Sort by post count descending (majority first); Uncategorized always last
		const sorted = order
			.filter(c => c.slug !== UNCATEGORIZED)
			.sort((a, b) => (map.get(b.slug)?.length ?? 0) - (map.get(a.slug)?.length ?? 0));
		if (seen.has(UNCATEGORIZED)) sorted.push({ slug: UNCATEGORIZED, name: 'Uncategorized' });

		return { categories: sorted, grouped: map };
	}, [posts]);

	const visibleCategories = useMemo(
		() => (activeCategory ? categories.filter(c => c.slug === activeCategory) : categories),
		[categories, activeCategory]
	);

	const loadMore = async () => {
		const data = await request<MorePostsByPublicationQuery, MorePostsByPublicationQueryVariables>(
			GQL_ENDPOINT,
			MorePostsByPublicationDocument,
			{
				first: 20,
				host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
				after: pageInfo.endCursor,
			},
		);
		if (!data.publication) return;
		const newPosts = data.publication.posts.edges.map((edge) => edge.node);
		const combined = [...posts, ...newPosts].sort((a, b) =>
			new Date(b.publishedAt || 0).getTime() - new Date(a.publishedAt || 0).getTime()
		);
		setPosts(combined);
		setPageInfo(data.publication.posts.pageInfo);
		setLoadedMore(true);
	};

	return (
		<AppProvider publication={publication} footerPosts={initialPosts}>
			<Layout>
				<Head>
					<title>All Posts - {publication.title}</title>
					<meta name="description" content={`All posts from ${publication.title}`} />
					<meta property="og:title" content={`All Posts - ${publication.title}`} />
					<meta property="og:description" content={`All posts from ${publication.title}`} />
					<meta property="og:image" content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)} />
					<meta property="twitter:card" content="summary_large_image" />
					<meta property="twitter:title" content={`All Posts - ${publication.title}`} />
					<meta property="twitter:description" content={`All posts from ${publication.title}`} />
					<meta property="twitter:image" content={publication.ogMetaData.image || getAutogeneratedPublicationOG(publication)} />
					<script
						type="application/ld+json"
						dangerouslySetInnerHTML={{ __html: JSON.stringify(addPublicationJsonLd(publication)) }}
					/>
				</Head>
				<Container className="mx-auto w-full">
					<PersonalHeader />
					<div className="max-w-6xl mx-auto w-full px-4 sm:px-5 py-12 flex flex-col gap-10">

						{/* ── Page heading ── */}
						<div>
							<h1 className="text-4xl md:text-5xl font-bold text-neutral-900 dark:text-neutral-50 mb-3">
								All Posts
							</h1>
							<p className="text-lg text-neutral-600 dark:text-neutral-300">
								{posts.length} article{posts.length !== 1 ? 's' : ''} grouped by category.
							</p>
						</div>

						{/* ── Category pill filter ── */}
						{categories.length > 1 && (
							<div className="flex flex-wrap gap-2">
								<button
									onClick={() => setActiveCategory(null)}
									className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm font-medium border transition-colors ${
										activeCategory === null
											? 'bg-blue-600 text-white border-blue-600'
											: 'bg-white dark:bg-neutral-900 text-neutral-600 dark:text-neutral-400 border-neutral-200 dark:border-neutral-700 hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400'
									}`}
								>
									All
								</button>
								{categories.map((cat) => (
									<button
										key={cat.slug}
										onClick={() => setActiveCategory(cat.slug === activeCategory ? null : cat.slug)}
										className={`inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-sm font-medium border transition-colors ${
											activeCategory === cat.slug
												? 'bg-blue-600 text-white border-blue-600'
												: 'bg-white dark:bg-neutral-900 text-neutral-600 dark:text-neutral-400 border-neutral-200 dark:border-neutral-700 hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400'
										}`}
									>
										{cat.name}
										<span className={`text-xs tabular-nums ${activeCategory === cat.slug ? 'text-blue-200' : 'text-neutral-400 dark:text-neutral-500'}`}>
											{grouped.get(cat.slug)?.length ?? 0}
										</span>
									</button>
								))}
							</div>
						)}

						{/* ── Grouped sections ── */}
						<div className="flex flex-col gap-16">
							{visibleCategories.map((cat) => {
								const catPosts = grouped.get(cat.slug) ?? [];
								if (catPosts.length === 0) return null;
								return (
									<section key={cat.slug} id={`cat-${cat.slug}`}>
										{/* Section header */}
										<div className="flex items-center gap-3 mb-6">
											<div className="flex items-center gap-2">
												{cat.slug !== UNCATEGORIZED ? (
													<Link
														href={`/tag/${cat.slug}`}
														className="text-xl md:text-2xl font-bold text-neutral-900 dark:text-neutral-50 hover:text-blue-600 dark:hover:text-blue-400 transition-colors"
													>
														{cat.name}
													</Link>
												) : (
													<h2 className="text-xl md:text-2xl font-bold text-neutral-900 dark:text-neutral-50">
														{cat.name}
													</h2>
												)}
												<span className="text-sm font-mono text-neutral-400 dark:text-neutral-500">
													({catPosts.length})
												</span>
											</div>
											<div className="flex-1 h-px bg-neutral-200 dark:bg-neutral-800" />
										</div>

										{/* Posts grid */}
										<MinimalPosts context="home" posts={catPosts} />
									</section>
								);
							})}
						</div>

						{/* ── Load more ── */}
						{!loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
							<div className="flex justify-center">
								<button
									onClick={loadMore}
									className="px-6 py-2.5 text-sm font-medium rounded-lg border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 text-neutral-700 dark:text-neutral-300 hover:bg-neutral-50 dark:hover:bg-neutral-800 transition-colors"
								>
									Load more posts
								</button>
							</div>
						)}
						{loadedMore && pageInfo.hasNextPage && pageInfo.endCursor && (
							<Waypoint onEnter={loadMore} bottomOffset={'10%'} />
						)}
					</div>
					<Footer />
				</Container>
			</Layout>
		</AppProvider>
	);
}

export const getStaticProps: GetStaticProps<Props> = async () => {
	const data = await request<PostsByPublicationQuery, PostsByPublicationQueryVariables>(
		GQL_ENDPOINT,
		PostsByPublicationDocument,
		{
			first: 20,
			host: process.env.NEXT_PUBLIC_HASHNODE_PUBLICATION_HOST,
		},
	);

	const publication = data.publication;
	if (!publication) {
		return {
			notFound: true,
		};
	}
	const initialPosts = (publication.posts.edges ?? []).map((edge) => edge.node);

	return {
		props: {
			publication,
			initialPosts,
			initialPageInfo: publication.posts.pageInfo,
		},
		revalidate: 1,
	};
};
